#+SETUPFILE: ./Setup/setupFile.org
#+OPTIONS: H:4 toc:t num:t \n:nil ::t |:t ^:{} -:t f:t *:t tex:t d:t tags:not-in-toc
#+HTML_HEAD_EXTRA: <style type="text/css"> blockquote {background:#EEEEEE; padding: 3px 13px}    </style>
#+HTML_HEAD_EXTRA: <style type="text/css"> pre {background:#EEEEEE; padding: 3px 13px}    </style>
#+TITLE: A small C++ linear algebra library

* Table of content                                           :TOC_3:noexport:
- [[#what-is-it][What is it?]]
- [[#doc-todo][Doc (TODO)]]
  - [[#types][Types]]
    - [[#matrix-types][Matrix types]]
  - [[#meta-programming][Meta-Programming]]
    - [[#some-generic-matrix-type-predicates][Some generic matrix type predicates]]
  - [[#functions][Functions]]
    - [[#aliasing][Aliasing]]
    - [[#same-mathematical-object][Same mathematical object]]
    - [[#similar][Similar]]
    - [[#copy][Copy]]
    - [[#lowerupper-bound][lower/upper bound]]
- [[#examples][Examples]]
  - [[#view-from-lowerupper-bounds][View from lower/upper bounds]]
  - [[#matrix-views-todo][Matrix views (TODO)]]
  - [[#conjugate-gradients][Conjugate gradients]]
  - [[#direct-call-to-lapack][Direct call to Lapack]]
- [[#faq][FAQ]]
  - [[#resizable-vectormatrix-][Resizable vector/matrix ?]]
  - [[#expression-template][Expression Template]]
  - [[#tiny-objects--intrinsics][Tiny objects & intrinsics]]

* What is it?

This is a light weight Linear Algebra C++17 library I am currently developing for my own stuff.

Early development stage *-> Do not use it right now!* 

The goals are:
- a good compromise between performance and library complexity
- a concise wrapping of libraries like Blas, Blis, Lapacke, etc.

* Doc (TODO)

** Types
*** Matrix types 

 For the moment I only have defined =dense= matrices (BLAS compatible with column major order):

 #+BEGIN_SRC sh :wrap "src cpp :eval never" :results output :exports results
cat $(pwd)/examples/some_matrix_types.cpp
 #+END_SRC

 #+RESULTS:
 #+BEGIN_src cpp :eval never
 #include "LinearAlgebra/dense/matrix.hpp"
 #include "LinearAlgebra/dense/vector.hpp"

 #include <iostream>

 using namespace LinearAlgebra;

 int
 main()
 {
   Matrix<double> M_1(4, 5);

   Symmetric_Matrix<int> M_2(4, 4);

   Tiny_Strict_Lower_Triangular_Matrix<float, 4, 7> M_3;

   std::cout << M_1 << std::endl;
   std::cout << M_2 << std::endl;
   std::cout << M_3 << std::endl;
 }
 #+END_src

 prints

 #+BEGIN_SRC sh :wrap "example :eval never" :results output :exports results
./build/examples/some_matrix_types
 #+END_SRC

 #+RESULTS:
 #+BEGIN_example :eval never

		0               0               0               0               0
		0               0               0               0               0
		0               0               0               0               0
		0               0               0               0               0

		0               X               X               X
		0               0               X               X
		0               0               0               X
		0               0               0               0

		X               X               X               X               X               X               X
		0               X               X               X               X               X               X
		0               0               X               X               X               X               X
		0               0               0               X               X               X               X
 #+END_example

 The generic definition for these matrix types is:
 #+begin_src cpp :eval never
template <T,                  // is the component type
          SPECIAL_STRUCTURE,  // is in {None, Symmetric, Hermitian, Triangular,
                              //        Unit_Triangular, Triangular_Strict}
          MASK,               // is in {None, Upper, Upper_Strict, Lower, Lower_Strict }
          N_TYPE,             // std::size_t or a std::integral_constant<std::size_t,N>
          M_TYPE,             // std::size_t or a std::integral_constant<std::size_t,M>
          LEADING_DIMENSION   // std::size_t or a std::integral_constant<std::size_t,LD>
          >                   //
class Default_Matrix;         // or {Default_Matrix_View, Default_Matrix_Const_View}
 #+end_src

 There are some alias covering the usual cases:

 |------------------------------------------------------+-----------------------------------------------------------|
 | Dynamic                                              | Static                                                    |
 |------------------------------------------------------+-----------------------------------------------------------|
 | Matrix<T> M(I_size, J_size);                         | Tiny_Matrix<T, I_SIZE, J_SIZE> M;                         |
 | Symmetric_Matrix<T> M(I_size, J_size);               | Tiny_Symmetric_Matrix<T, SIZE> M;                         |
 | Hermitian_Matrix<T> M(I_size, J_size);               | Tiny_Hermitian_Matrix<T, SIZE> M;                         |
 | Lower_Triangular_Matrix<T> M(I_size, J_size);        | Tiny_Lower_Triangular_Matrix<T, I_SIZE, J_SIZE> M;        |
 | Upper_Triangular_Matrix<T> M(I_size, J_size);        | Tiny_Upper_Triangular_Matrix<T, I_SIZE, J_SIZE> M;        |
 | Lower_Triangular_Strict_Matrix<T> M(I_size, J_size); | Tiny_Lower_Triangular_Strict_Matrix<T, I_SIZE, J_SIZE> M; |
 | Upper_Triangular_Strict_Matrix<T> M(I_size, J_size); | Tiny_Upper_Triangular_Strict_Matrix<T, I_SIZE, J_SIZE> M; |
 | Lower_Unit_Triangular_Matrix<T> M(I_size, J_size);   | Tiny_Lower_Unit_Triangular_Matrix<T, I_SIZE, J_SIZE> M;   |
 | Upper_Unit_Triangular_Matrix<T> MI_size, J_size);    | Tiny_Upper_Unit_Triangular_Matrix<T, I_SIZE, J_SIZE> M;   |
 |------------------------------------------------------+-----------------------------------------------------------|


 Please note that by default Symmetric/Hermitian matrices are stored in their *Lower* part.

 For each case you can also use *views*, there are two types of view:
 mutable one and constant one. For instance:

 #+begin_src cpp :eval never
Matrix<double> M(10, 5);

auto view = view_as_lower_triangular_strict(M.as_const());
 #+end_src

 will return a constant view (a lightweight matrix where only pointers
 are stored and not owned).

** Meta-Programming 

*** Some generic matrix type predicates

*File:* [[file:src/LinearAlgebra/utils/sfinae_vmt_helpers.hpp][LinearAlgebra/utils/sfinae_vmt_helpers.hpp]]

*Note*: these predicates will also work for sparse matrices (they are
      not restricted to dense one).

Checks if the matrix is defined by its lower or upper part:

#+BEGIN_SRC cpp :eval never
template <typename MATRIX>
constexpr bool Is_Upper_Matrix_Storage_v = Is_Upper_Matrix_Storage<MATRIX>::value;

template <typename MATRIX>
constexpr bool Is_Upper_Strict_Matrix_Storage_v = Is_Upper_Strict_Matrix_Storage<MATRIX>::value;

template <typename MATRIX>
constexpr bool Is_Lower_Matrix_Storage_v = Is_Lower_Matrix_Storage<MATRIX>::value;

template <typename MATRIX>
constexpr bool Is_Lower_Strict_Matrix_Storage_v = Is_Lower_Strict_Matrix_Storage<MATRIX>::value;
#+END_SRC


Checks for special structure:

#+BEGIN_SRC cpp :eval never
template <typename MATRIX>
constexpr bool Is_Full_Matrix_v = Is_Full_Matrix<MATRIX>::value;

template <typename MATRIX>
constexpr bool Is_Symmetric_Matrix_v = Is_Symmetric_Matrix<MATRIX>::value;

template <typename MATRIX>
constexpr bool Is_Hermitian_Matrix_v = Is_Hermitian_Matrix<MATRIX>::value;

template <typename MATRIX>
constexpr bool Is_Triangular_Matrix_v = Is_Triangular_Matrix<MATRIX>::value;

template <typename MATRIX>
constexpr bool Is_Unit_Triangular_Matrix_v = Is_Unit_Triangular_Matrix<MATRIX>::value;
#+END_SRC

*Usage example:*

#+BEGIN_SRC cpp :eval never
static_assert(Is_Symmetric_Matrix_v<Symmetric_Matrix<double>>);
static_assert(Is_Lower_Matrix_Storage_v<Symmetric_Matrix<double>>);
#+END_SRC

** Functions

*** Aliasing 
    :PROPERTIES:
    :ID:       7207062d-f90b-4646-a5f0-dd692083176f
    :END:
    :BACKLINKS:
    [2020-04-25 Sat 16:39] <- [[id:4a5f5853-bb5d-4935-abd0-3996a3d62a4e][Same mathematical object]]
    :END:

Test if two objects are aliased or not.
#+BEGIN_SRC cpp :eval never
bool status = are_not_aliased_p(vector0, matrix1)
#+END_SRC

*Note:* it is easy/fast to check if two objects are *not* aliased (memory
blocks don't overlap). It can be more tricky (with all the possible
memory increments/strides) to check if two objects are aliased. That's
the reason why we also have this function:

#+BEGIN_SRC cpp :eval never
bool status = are_maybe_aliased_p(vector0, matrix1)
#+END_SRC

Also see: [[id:4a5f5853-bb5d-4935-abd0-3996a3d62a4e][Same mathematical object]]

*** Same mathematical object
    :PROPERTIES:
    :ID:       4a5f5853-bb5d-4935-abd0-3996a3d62a4e
    :END:

A predicate that checks if two objects represent *exactly* the same
"mathematical" object. By exactly we mean:
- same memory
- same dimension

This is possible, think to a matrix and its view.

#+BEGIN_SRC cpp :eval never
bool status = same_mathematical_object_p(matrix_1,matrix_2);
#+END_SRC

*Note:* according to the definition, two identical mathematical objects
are trivially [[id:7207062d-f90b-4646-a5f0-dd692083176f][Aliased]].

*** Similar
    :PROPERTIES:
    :ID:       5afec5bb-bd6c-4173-b513-3b49cef5005a
    :END:
    :BACKLINKS:
    [2020-04-24 Fri 12:50] <- [[id:07b3fa16-4842-4bf2-9893-7d6626813c9b][Copy]]
    :END:

 Create an *uninitialized* object of the same type and same dimension:
 #+BEGIN_SRC cpp :eval never
auto u = similar(v);
 #+END_SRC

 a variant is to change type:

 #+BEGIN_SRC cpp :eval never
Vector<double> v;
auto int_u = similar(Type_v<int>,v);
 #+END_SRC

*** Copy
    :PROPERTIES:
    :ID:       07b3fa16-4842-4bf2-9893-7d6626813c9b
    :END:

  Like [[id:5afec5bb-bd6c-4173-b513-3b49cef5005a][Similar]] but also performs a copy of the element

  #+BEGIN_SRC cpp :eval never
auto u = copy(v);
auto int_u = copy(Type_v<int>,v);
  #+END_SRC

*** lower/upper bound
    :PROPERTIES:
    :ID:       3ba0b7cf-95c2-436e-a90c-11e751898497
    :END:

These functions mimic =std::lower_bound=, =std::upper_bound= but work with indices.

  #+BEGIN_SRC cpp :eval never
// Returns the first index *idx* such "value <= x[idx]"
//         or X.size() if such element index does not exist
//
template <typename IMPL>
std::size_t
lower_bound(const Dense_Vector_Crtp<IMPL>& X, const Element_Type_t<IMPL>& value);

// Returns the first index *idx* such "value < x[idx]"
//         or X.size() if such element index does not exist
//
template <typename IMPL>
std::size_t
upper_bound(const Dense_Vector_Crtp<IMPL>& X, const Element_Type_t<IMPL>& value);
 #+END_SRC

They can be used to create view, see [[id:907674bf-2cae-4a34-8061-b5039240e93b][View from lower/upper bounds]]

* Examples

** View from lower/upper bounds
   :PROPERTIES:
   :ID:       907674bf-2cae-4a34-8061-b5039240e93b
   :END:
   :BACKLINKS:
   [2020-05-08 Fri 12:03] <- [[id:3ba0b7cf-95c2-436e-a90c-11e751898497][lower/upper bound]]
   :END:

#+BEGIN_SRC sh :wrap "src cpp :eval never" :results output :exports results
cat $(pwd)/examples/lb_ub.cpp
#+END_SRC

#+RESULTS:
#+BEGIN_src cpp :eval never
#include "LinearAlgebra/vector.hpp"
#include "LinearAlgebra/utils/lower_upper_bound.hpp"

using namespace LinearAlgebra;

int
main()
{
  double data[13] = {1, 1, 2, 3, 3, 3, 3, 4, 4, 4, 5, 5, 6};
  auto X          = create_vector_view(data, 13);

  std::cout << X << std::endl;
  
  auto X_3 = create_vector_view(X, lower_bound(X, 3), upper_bound(X, 3));

  X_3=10;

  std::cout << X << std::endl;
}
#+END_src

prints:

#+BEGIN_SRC sh :wrap "example :eval never" :results output :exports results
./build/examples/lb_ub
#+END_SRC

#+RESULTS:
#+BEGIN_example :eval never

1
1
2
3
3
3
3
4
4
4
5
5
6

1
1
2
10
10
10
10
4
4
4
5
5
6
#+END_example

** Matrix views (TODO)

#+BEGIN_SRC sh :wrap "src cpp :eval never" :results output :exports results
cat $(pwd)/examples/matrix_view.cpp
#+END_SRC

#+RESULTS:
#+BEGIN_src cpp :eval never
#include "LinearAlgebra/matrix.hpp"

using namespace LinearAlgebra;

int
main()
{
  Tiny_Matrix<int, 5, 6> mat;

  mat = 1;

  auto view_mat = create_matrix_view(mat, 1, 3, 2, 5);

  view_mat = -1;

  std::cout << "full matrix:" << mat << std::endl;

  //================

  Tiny_Symmetric_Matrix<int, 6> mat_S;

  create_matrix_view_full(mat_S) = 0;  // fill the full matrix

  mat_S = 1;  // here as mat_S is symmetric
              // only fill lower triangular part is filled

  // Take a subview of a _symmetric matrix_
  auto view_mat_S = create_matrix_view(mat_S, 1, 3, 1, 3);

  view_mat_S = -1;  // here the subview mat_S is symmetric too and
                    // only the lower triangular part will be filled

  std::cout << "full matrix:" << create_matrix_view_full(mat_S) << std::endl;
  std::cout << "submatrix:" << mat_S << std::endl;
}
#+END_src

prints:

#+BEGIN_SRC sh :wrap "example :eval never" :results output :exports results
./build/examples/matrix_view
#+END_SRC

#+RESULTS:
#+BEGIN_example :eval never
full matrix:
               1               1               1               1               1               1
               1               1              -1              -1              -1               1
               1               1              -1              -1              -1               1
               1               1               1               1               1               1
               1               1               1               1               1               1
full matrix:
               1               0               0               0               0               0
               1              -1               0               0               0               0
               1              -1              -1               0               0               0
               1               1               1               1               0               0
               1               1               1               1               1               0
               1               1               1               1               1               1
submatrix:
               1               X               X               X               X               X
               1              -1               X               X               X               X
               1              -1              -1               X               X               X
               1               1               1               1               X               X
               1               1               1               1               1               X
               1               1               1               1               1               1
#+END_example

** Conjugate gradients

This is only for demo purpose as a real implementation makes more sense with sparse matrices + a preconditioner.

#+BEGIN_SRC sh :wrap "src cpp :eval never" :results output :exports results
cat $(pwd)/examples/conjugate_gradients.cpp
#+END_SRC

#+RESULTS:
#+BEGIN_src cpp :eval never
#include "LinearAlgebra/matrix.hpp"
#include "LinearAlgebra/vector.hpp"

using namespace LinearAlgebra;

// Illustrates dynamic vs static size vectors
//
template <typename T>
auto
create_vector(const std::size_t n)
{
  return Vector<T>{n};
}
template <typename T, std::size_t N>
auto
create_vector(const std::integral_constant<std::size_t, N>)
{
  return Tiny_Vector<T, N>{};
}

// Basic CG implementation
// https://en.wikipedia.org/wiki/Conjugate_gradient_method
//
template <typename A_IMPL, typename X0_IMPL, typename B_IMPL>
bool
cg(const Matrix_Crtp<A_IMPL>& A, Dense_Vector_Crtp<X0_IMPL>& X0, const Dense_Vector_Crtp<B_IMPL>& b)
{
  // Parameters
  //
  const double eps         = 1e-6;
  const double squared_eps = eps * eps;
  const size_t max_iter    = 100;

  // Sanity check
  //
  static_assert(A_IMPL::matrix_special_structure_type::value ==  // For demo...
                Matrix_Special_Structure_Enum::Symmetric);       // could be: SFINAE,
                                                                 // hermitian, etc...

  assert(all_sizes_are_equal_p(A.I_size(), A.J_size(), X0.size(), b.size()));

  // Working vector type, use a static size one if possible
  //
  using element_type = Common_Element_Type_t<A_IMPL, X0_IMPL, B_IMPL>;
  const auto n       = get_static_size_if_any(A.I_size(), A.J_size(), X0.size(), b.size());

  auto r  = create_vector<element_type>(n);
  auto p  = create_vector<element_type>(n);
  auto Ap = create_vector<element_type>(n);

  // Initialization
  //
  r = b - A * X0;

  auto squared_norm_r_old = dot(r, r);

  if (squared_norm_r_old < squared_eps)
  {
    return true;
  }

  p = r;

  // Main loop
  //
  for (size_t i = 0; i < max_iter; i++)
  {
    Ap = A * p;

    auto alpha = squared_norm_r_old / dot(p, Ap);

    X0 = X0 + alpha * p;

    r = r - alpha * Ap;

    auto squared_norm_r_new = dot(r, r);

    std::cout << "iter " << i << " residue " << squared_norm_r_new << std::endl;

    if (squared_norm_r_new < squared_eps)
    {
      return true;
    }

    p = r + squared_norm_r_new / squared_norm_r_old * p;

    squared_norm_r_old = squared_norm_r_new;
  }
  return false;
}

int
main()
{
  // Dynamic vectors/matrices

  Symmetric_Matrix<double> M(10, 10);
  Vector<double> X0(10);
  Vector<double> b(10);

  // Here static one, no more dynamic memory allocations.

  // Tiny_Symmetric_Matrix<double, 10, 10> M;
  // Tiny_Vector<double, 10> X0;
  // Tiny_Vector<double, 10> b;

  M = 1;

  create_vector_view_matrix_diagonal(M) = 20;
  M(5, 6)                               = 2;
  M(6, 5)                               = 2;

  b  = 1;
  X0 = 0;

  bool status = cg(M, X0, b);

  std::cout << X0 << std::endl;
  std::cout << std::boolalpha << status << std::endl;
}
#+END_src

** Direct call to Lapack

#+BEGIN_SRC sh :wrap "src cpp :eval never" :results output :exports results
cat $(pwd)/examples/lapack_potrf.cpp
#+END_SRC

#+RESULTS:
#+BEGIN_src cpp :eval never
#include "LinearAlgebra/lapack/lapack.hpp"
#include "LinearAlgebra/matrix.hpp"
#include "LinearAlgebra/vector.hpp"

using namespace LinearAlgebra;

int
main()
{
  const size_t n = 5;

  Vector<double> v(n), w(n);
  v = 1;

  Symmetric_Matrix<double> M(n, n);

  M                                     = 0;
  create_vector_view_matrix_diagonal(M) = 10;
  M(4, 0)                               = 5;

  w = M * v;

  std::cout << "symmetric M :" << M << std::endl << std::endl;
  std::cout << "v :" << v << std::endl << std::endl;
  std::cout << "w = M.v :" << w << std::endl << std::endl;

  // Low level call of lapack: L*L^t decomposition
  //
  int info = Lapack::potrf(M);
  assert(info == 0);

  // Create a constant view defining L
  // (symmetric matrix uses lower part)
  //
  auto L = create_matrix_view_lower_triangular(M.as_const());
  std::cout << "L :" << L << std::endl << std::endl;

  // inplace solve of w = M.v = L.L^t.v ...
  // ... at the end w "contains" v
  //
  w = inverse(L) * w;             // L^(-1).w = L^t.v
  w = inverse(transpose(L)) * w;  // L^(-t).L^(-1).w = v

  std::cout << "v such that w=M.v :" << w << std::endl;
}
#+END_src

prints:

#+BEGIN_SRC sh :wrap "example :eval never" :results output :exports results
./build/examples/lapack_potrf
#+END_SRC

#+RESULTS:
#+BEGIN_example :eval never
symmetric M :
              10               X               X               X               X
               0              10               X               X               X
               0               0              10               X               X
               0               0               0              10               X
               5               0               0               0              10

v :
1
1
1
1
1

w = M.v :
15
10
10
10
15

L :
         3.16228               X               X               X               X
               0         3.16228               X               X               X
               0               0         3.16228               X               X
               0               0               0         3.16228               X
         1.58114               0               0               0         2.73861

v such that w=M.v :
1
1
1
1
1
#+END_example


* FAQ

** Resizable vector/matrix ?

In general vectors or matrices *cannot be resized*. 

This avoids introducing an asymmetry in the code between dynamic &
static size objects. This asymmetry would have come with some extra
complications both for the developer and the user who want to
implement some generic routines.

** Expression Template 

Only a reduced number of expressions are supported (TODO: list
them!). 

By example you can write
#+begin_src cpp :eval never
V=2*transpose(M)*U+2*V
 #+end_src
as this expression can be directly mapped to a Blas subroutine.

However, you cannot write, in full generality, things like:
#+begin_src cpp :eval never
V=2*transpose(M)*M**M*U+2*V
#+end_src

Please note that, all in all, this constraint has some positive side
effects as it reduces the "chance" of introducing hidden temporary
creations.

Also note that beside Expression Template you can call available
expressions using reverse polish notation, by example

#+begin_src cpp :eval never
V = 2 * transpose(M) * U + 3 * V
#+end_src

can be computed by calling:
#+begin_src cpp :eval never
assign(V, _plus_, _product_, _product_, 2, _transpose_, M, U, _product_, 3, _lhs_);
#+end_src


** Tiny objects & intrinsics

For the moment I have not introduced all the machinery that "manually"
generates simd code.  This would have required a lot to be introduced,
like cpu dependent simd definitions, =aligned= or =packed= template
parameters etc... Really not my priority for the moment... Some other
libs do a great job here.
