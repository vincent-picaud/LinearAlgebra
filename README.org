#+OPTIONS: H:3 toc:t num:t \n:nil ::t |:t ^:{} -:t f:t *:t tex:t d:t tags:not-in-toc
#+HTML_HEAD_EXTRA: <style type="text/css"> blockquote {background:#EEEEEE; padding: 3px 13px}    </style>
#+HTML_HEAD_EXTRA: <style type="text/css"> pre {background:#EEEEEE; padding: 3px 13px}    </style>
#+TITLE: Another C++ Linear Algerba library

* What is it?

This library is an *crazy* attempt to create another C++ Linear Algebra library. 

Compared to already existing libs like: [[http://eigen.tuxfamily.org/index.php?title=Main_Page][Eigen]], [[https://bitbucket.org/blaze-lib/blaze/src/master/][Blaze]], ...

The expected goal is a reasonable compilation time and with a concise
implementation wrapping libraries like Blas, Lapacke, etc. I want a
minimal number of lines of code!

In peculiar, for the moment I will not immediately implement
 Expression Templates, but simply provide call sites like:

#+begin_src cpp :eval never
expr(M, _assign_,  3, _matrix_0_, _plus_, _identity_, A, _transpose_, B);
#+end_src

which means: M = 3.M + A.B^t, where M, A and B are matrices.

The =_matrix_0_= tag means reuse the first (=0) already seen matrix
argument.

*Reasons:* expression templates
- increase compilation time
- can always "hide" some temporary creation


** Compromises

To make the code simpler I have done some compromises

- Vector/Matrix cannot be resized (reason: static vector/matrix
  cannot be resized whereas dynamic one can. This introduce an
  asymmetry in the code that comes with some extra complications),
- I did not introduce =aligned= or =packed= template parameters (by
  consequence I did not introduce simd intrinsics). This can be a
  performance limitation for small vector/matrix objects. However,
  this has no effect for big vector/matrix as we use BLAS whenever
  this is possible.

** Disclaimer

 The library is at its early, early, early... development stage. I
 have made it public only for the curious...


* Examples

** Matrix types 

#+BEGIN_SRC sh :wrap "src cpp :eval never" :results output :exports results
cat $(pwd)/examples/some_matrix_types.cpp
#+END_SRC

#+RESULTS:
#+begin_src cpp :eval never
#include "LinearAlgebra/dense/matrix.hpp"
#include "LinearAlgebra/dense/vector.hpp"

#include <iostream>

using namespace LinearAlgebra;

int
main()
{
  Matrix<double> M_1(4, 5);

  Symmetric_Matrix<int> M_2(4, 4);

  Tiny_Lower_Triangular_Strict_Matrix<float, 4, 7> M_3;

  std::cout << M_1 << std::endl;
  std::cout << M_2 << std::endl;
  std::cout << M_3 << std::endl;
}
#+end_src

prints

#+BEGIN_SRC sh :wrap "example :eval never" :results output :exports results
./build/examples/some_matrix_types
#+END_SRC

#+RESULTS:
#+begin_example :eval never

               0               0               0               0               0
               0               0               0               0               0
               0               0               0               0               0
               0               0               0               0               0

               0               X               X               X
               0               0               X               X
               0               0               0               X
               0               0               0               0

               X               X               X               X               X               X               X
               0               X               X               X               X               X               X
               0               0               X               X               X               X               X
               0               0               0               X               X               X               X
#+end_example

** Expression usage example

Again this is not expression template, but IMHO this is still readable
and you do not have hidden temporary (plsu shorter compilation time).

#+BEGIN_SRC sh :wrap "src cpp :eval never" :results output :exports results
cat $(pwd)/examples/expr_usage.cpp
#+END_SRC

#+RESULTS:
#+begin_src cpp :eval never
#include "LinearAlgebra/vector.hpp"

#include <ccomplex>
#include <iostream>

using namespace LinearAlgebra;

int
main()
{
  using T = std::complex<double>;

  Vector<T> V_1(5), V_2(5);

  std::cout << V_1 << std::endl;

  expr(V_2, _assign_, V_1);

  std::cout << V_2 << std::endl;
}
#+end_src

prints

#+BEGIN_SRC sh :wrap "example :eval never" :results output :exports results
./build/examples/expr_usage
#+END_SRC

#+RESULTS:
#+begin_example :eval never

(0,0)
(0,0)
(0,0)
(0,0)
(0,0)

(0,0)
(0,0)
(0,0)
(0,0)
(0,0)
#+end_example

* API Documentation

** Available matrix types

For the moment only dense BLAS compatibles (column major) matrices are
defined (I expect to add sparse & triangular matrices too).

The generic definition for these matrix types is:
#+begin_src cpp :eval never
template <typename T, Matrix_Special_Structure_Enum SPECIAL_STRUCTURE,
          Matrix_Storage_Mask_Enum MASK, typename N_TYPE, typename M_TYPE,
          typename LEADING_DIMENSION>
class Default_Matrix { /* ... */ };
#+end_src

where 

| T                 | is the element_type, can be a float, int or any user type                          |
| SPECIAL_STRUCTURE | is in {None, Symmetric, Hermitian, Triangular, Unit_Triangular, Triangular_Strict} |
| MASK              | is in {None, Upper, Upper_Strict, Lower, Lower_Strict }                            |
| N_TYPE            | is either std::size_t or a std::integral_constant<std::size_t,N>                   |
| M_TYPE            | is either std::size_t or a std::integral_constant<std::size_t,M>                   |
| LEADING_DIMENSION | is either std::size_t or a std::integral_constant<std::size_t,LD>                  |

There are some alias covering the usual cases. Those with the =Tiny=
prefix denote *static size* (no memory allocation).


|--------------------------------------------+-----------------------------------------|
| Matrix<T>                                  | Regular matrix                          |
| Tiny_Matrix<T,N,M>                         | (+ with static size)                    |
|--------------------------------------------+-----------------------------------------|
| Lower_Triangular_Strict_Matrix<T>          | Lower Triangular Strict (no diagonal)   |
| Tiny_Lower_Triangular_Strict_Matrix<T,N,M> | (+ with static size)                    |
|--------------------------------------------+-----------------------------------------|
| Upper_Triangular_Strict_Matrix<T>          | Upper Triangular Strict (no diagonal)   |
| Tiny_Upper_Triangular_Strict_Matrix<T,N,M> | (+ with static size)                    |
|--------------------------------------------+-----------------------------------------|
| Lower_Unit_Triangular_Matrix<T>            | Lower Unit Triangular (diagonal=1)      |
| Tiny_Lower_Unit_Triangular_Matrix<T,N,M>   | (+ with static size)                    |
|--------------------------------------------+-----------------------------------------|
| Upper_Unit_Triangular_Matrix<T>            | Upper Unit Triangular (no diagonal=1)   |
| Tiny_Upper_Unit_Triangular_Matrix<T,N,M>   | (+ with static size)                    |
|--------------------------------------------+-----------------------------------------|
| Symmetric_Matrix<T>                        | Symmetric Matrix (lower part is stored) |
| Tiny_Symmetric_Matrix<T,N,M>               | (+ with static size)                    |
|--------------------------------------------+-----------------------------------------|
| Hermitian_Matrix<T>                        | Hermitian Matrix (lower part is stored) |
| Tiny_Hermitian_Matrix<T,N,M>               | (+ with static size)                    |
|--------------------------------------------+-----------------------------------------|

CAVEAT: add Triangular matrices! (missing)

For each case you can also use *views*, there are two types of view:
mutable one and constant one. For instance:

#+begin_src cpp :eval never
Matrix<double> M(10, 5);

auto view = view_as_lower_triangular_strict(M.as_const());
#+end_src

will return a constant view (a lightweight matrix where only pointers
are stored and not owned) of type:

#+begin_src cpp :eval never
Default_Matrix_Const_View<T, SPECIAL_STRUCTURE, MASK, N_TYPE, M_TYPE, LEADING_DIMENSION>
#+end_src

* Developper documentation

** =meta=

| =Has_Static_Size_v<>=        | .file:/test/meta/size_utils.cpp |
| =Any_Has_Static_Size_v<...>= |                                 |

