#+SETUPFILE: ./Setup/setupFile.org
#+OPTIONS: H:3 toc:t num:t \n:nil ::t |:t ^:{} -:t f:t *:t tex:t d:t tags:not-in-toc
#+HTML_HEAD_EXTRA: <style type="text/css"> blockquote {background:#EEEEEE; padding: 3px 13px}    </style>
#+HTML_HEAD_EXTRA: <style type="text/css"> pre {background:#EEEEEE; padding: 3px 13px}    </style>
#+TITLE: A small C++ linear algebra library

* What is it?

This is a light weight Linear Algebra C++17 library I am currently developing for my own stuff.

Early development stage *-> Do not use it right now!* 

The goals are:
- a good compromise between performance and library complexity
- a concise wrapping of libraries like Blas, Blis, Lapacke, etc.

* Doc (TODO)

** Matrix types 

For the moment I only have defined =dense= matrices (BLAS compatible with column major order):

#+BEGIN_SRC sh :wrap "src cpp :eval never" :results output :exports results
cat $(pwd)/examples/some_matrix_types.cpp
#+END_SRC

#+RESULTS:
#+BEGIN_src cpp :eval never
#include "LinearAlgebra/dense/matrix.hpp"
#include "LinearAlgebra/dense/vector.hpp"

#include <iostream>

using namespace LinearAlgebra;

int
main()
{
  Matrix<double> M_1(4, 5);

  Symmetric_Matrix<int> M_2(4, 4);

  Tiny_Strict_Lower_Triangular_Matrix<float, 4, 7> M_3;

  std::cout << M_1 << std::endl;
  std::cout << M_2 << std::endl;
  std::cout << M_3 << std::endl;
}
#+END_src

prints

#+BEGIN_SRC sh :wrap "example :eval never" :results output :exports results
./build/examples/some_matrix_types
#+END_SRC

#+RESULTS:
#+begin_example :eval never

               0               0               0               0               0
               0               0               0               0               0
               0               0               0               0               0
               0               0               0               0               0

               0               X               X               X
               0               0               X               X
               0               0               0               X
               0               0               0               0

               X               X               X               X               X               X               X
               0               X               X               X               X               X               X
               0               0               X               X               X               X               X
               0               0               0               X               X               X               X
#+end_example

The generic definition for these matrix types is:
#+begin_src cpp :eval never
template <typename T,                     // is the component type
          Matrix_Special_Structure_Enum   //
              SPECIAL_STRUCTURE,          // is in {None, Symmetric, Hermitian, Triangular,
                                          //        Unit_Triangular, Triangular_Strict}
          Matrix_Storage_Mask_Enum MASK,  // is in {None, Upper, Upper_Strict, Lower, Lower_Strict }
          typename N_TYPE,                // std::size_t or a std::integral_constant<std::size_t,N>
          typename M_TYPE,                // std::size_t or a std::integral_constant<std::size_t,M>
          typename LEADING_DIMENSION      // std::size_t or a std::integral_constant<std::size_t,LD>
          >                               //
class Default_Matrix;                     // or {Default_Matrix_View, Default_Matrix_Const_View}
#+end_src

There are some alias covering the usual cases:

#+begin_src cpp :eval never
Matrix<T> M(I_size, J_size);
Tiny_Matrix<T, I_SIZE, J_SIZE> M;

Lower_Triangular_Strict_Matrix<T> M(I_size_, J_size);
Tiny_Lower_Triangular_Strict_Matrix<T, I_SIZE, J_SIZE> M;

Upper_Triangular_Strict_Matrix<T> M(I_size_, J_size);
Tiny_Upper_Triangular_Strict_Matrix<T, I_SIZE, J_SIZE> M;

Lower_Unit_Triangular_Matrix<T> M(I_size_, J_size);
Tiny_Lower_Unit_Triangular_Matrix<T, I_SIZE, J_SIZE> M;

Upper_Unit_Triangular_Matrix<T> MI_size_, J_size);
Tiny_Upper_Unit_Triangular_Matrix<T, I_SIZE, J_SIZE> M;

Symmetric_Matrix<T> M(I_size_, J_size);  // I_size = J_size
Tiny_Symmetric_Matrix<T, SIZE> M;

Hermitian_Matrix<T> M;  // I_size = J_size
Tiny_Hermitian_Matrix<T, SIZE> M;
#+end_src

Please note that by default Symmetric/Hermitian matrices are stored in their *Lower* part.

For each case you can also use *views*, there are two types of view:
mutable one and constant one. For instance:

#+begin_src cpp :eval never
Matrix<double> M(10, 5);

auto view = view_as_lower_triangular_strict(M.as_const());
#+end_src

will return a constant view (a lightweight matrix where only pointers
are stored and not owned).

* Examples

** Conjugate gradients

This is only for demo purpose as a real implementation makes more sense with sparse matrices + a preconditioner.

#+BEGIN_SRC sh :wrap "src cpp :eval never" :results output :exports results
cat $(pwd)/examples/conjugate_gradients.cpp
#+END_SRC

#+RESULTS:
#+BEGIN_src cpp :eval never
#include "LinearAlgebra/matrix.hpp"
#include "LinearAlgebra/vector.hpp"

using namespace LinearAlgebra;

// Illustrates dynamic vs static size vectors
//
template <typename T>
auto
create_vector(const std::size_t n)
{
  return Vector<T>{n};
}
template <typename T, std::size_t N>
auto
create_vector(const std::integral_constant<std::size_t, N>)
{
  return Tiny_Vector<T, N>{};
}

// Basic CG implementation
// https://en.wikipedia.org/wiki/Conjugate_gradient_method
//
template <typename A_IMPL, typename X0_IMPL, typename B_IMPL>
bool
cg(const Matrix_Crtp<A_IMPL>& A, Dense_Vector_Crtp<X0_IMPL>& X0, const Dense_Vector_Crtp<B_IMPL>& b)
{
  // Parameters
  //
  const double eps         = 1e-6;
  const double squared_eps = eps * eps;
  const size_t max_iter    = 100;

  // Sanity check
  //
  assert(all_sizes_are_equal_p(A.I_size(), A.J_size(), X0.size(), b.size()));

  // Working vector type, use a static size one if possible
  //
  using element_type = Common_Element_Type_t<A_IMPL, X0_IMPL, B_IMPL>;
  const auto n       = get_static_size_if_any(A.I_size(), A.J_size(), X0.size(), b.size());

  auto r  = create_vector<element_type>(n);
  auto p  = create_vector<element_type>(n);
  auto Ap = create_vector<element_type>(n);

  // Initialization
  //
  r = b - A * X0;

  auto squared_norm_r_old = dot(r, r);

  if (squared_norm_r_old < squared_eps)
  {
    return true;
  }

  p = r;

  // Main loop
  //
  for (size_t i = 0; i < max_iter; i++)
  {
    Ap = A * p;

    auto alpha = squared_norm_r_old / dot(p, Ap);

    X0 = X0 + alpha * p;

    r = r - alpha * Ap;

    auto squared_norm_r_new = dot(r, r);

    std::cout << "iter " << i << " residue " << squared_norm_r_new << std::endl;

    if (squared_norm_r_new < squared_eps)
    {
      return true;
    }

    p = r + squared_norm_r_new / squared_norm_r_old * p;

    squared_norm_r_old = squared_norm_r_new;
  }
  return false;
}

int
main()
{
  // Dynamic vectors/matrices

  Matrix<double> M(10, 10);
  Vector<double> X0(10);
  Vector<double> b(10);

  // Here static one, no more dynamic memory allocations.

  // Tiny_Matrix<double, 10, 10> M;
  // Tiny_Vector<double, 10> X0;
  // Tiny_Vector<double, 10> b;

  M = 1;

  create_vector_view_matrix_diagonal(M) = 20;
  M(5, 6)                               = 2;
  M(6, 5)                               = 2;

  b  = 1;
  X0 = 0;

  bool status = cg(M, X0, b);

  std::cout << X0 << std::endl;
  std::cout << std::boolalpha << status << std::endl;
}
#+END_src


* FAQ

** Resizable vector/matrix ?

In general vectors or matrices *cannot be resized*. 

This avoids introducing an asymmetry in the code between dynamic &
static size objects. This asymmetry would have come with some extra
complications both for the developer and the user who want to
implement some generic routines.

** Expression Template 

Only a reduced number of expressions are supported (TODO: list
them!). 

By example you can write
#+begin_src cpp :eval never
V=2*transpose(M)*U+2*V
 #+end_src
as this expression can be directly mapped to a Blas subroutine.

However, you cannot write, in full generality, things like:
#+begin_src cpp :eval never
V=2*transpose(M)*M**M*U+2*V
#+end_src

Please note that, all in all, this constraint has some positive side
effects as it reduces the "chance" of introducing hidden temporary
creations.

Also note that beside Expression Template you can call available
expressions using reverse polish notation, by example

#+begin_src cpp :eval never
V = 2 * transpose(M) * U + 3 * V
#+end_src

can be computed by calling:
#+begin_src cpp :eval never
assign(V, _plus_, _product_, _product_, 2, _transpose_, M, U, _product_, 3, _lhs_);
#+end_src


** Tiny objects & intrinsics

For the moment I have not introduced all the machinery that "manually"
generates simd code.  This would have required a lot to be introduced,
like cpu dependent simd definitions, =aligned= or =packed= template
parameters etc... Really not my priority for the moment... Some other
libs do a great job here.
