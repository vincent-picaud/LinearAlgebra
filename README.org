#+SETUPFILE: ./Setup/setupFile.org
#+OPTIONS: H:3 toc:t num:t \n:nil ::t |:t ^:{} -:t f:t *:t tex:t d:t tags:not-in-toc
#+HTML_HEAD_EXTRA: <style type="text/css"> blockquote {background:#EEEEEE; padding: 3px 13px}    </style>
#+HTML_HEAD_EXTRA: <style type="text/css"> pre {background:#EEEEEE; padding: 3px 13px}    </style>
#+TITLE: Another C++ Linear Algerba library

* What is it?

This library is a light weight Linear Algebra C++17 library. 

The goals are:
- a good compromise between performance and library complexity
- a concise wrapping of libraries like Blas, Lapacke, etc.

The library is at its early... development stage. *Do not use it right
now!*

** Expression template 
   :PROPERTIES:
   :ID:       3046d589-3294-40e0-9bff-63895bddfa5c
   :END:

Only a reduced number of expression are supported. By exemple you can write
#+begin_src cpp :eval never
V=2*transpose(M)*U+2*V
 #+end_src
as this expression can be directly mapped to Blas.

However, you cannot write things like:
#+begin_src cpp :eval never
V=2*transpose(M)*M**M*U+2*V
#+end_src
as these kind of expression generally need temporary creation. 

Please note that, all in all, this constraint as some positive side effects as it
reduces the "chance" of hidden temporary creation.

** Resizable vectors, matrices

** Component like operator

#+BEGIN_SRC sh :wrap "src cpp :eval never" :results output :exports results
cat $(pwd)/examples/cwise_operation.cpp
#+END_SRC

#+RESULTS:
#+BEGIN_src cpp :eval never
#include "LinearAlgebra/vector.hpp"

using namespace LinearAlgebra;

int
main()
{
  Tiny_Vector<int, 3> V, W;

  V[0] = 1;
  V[1] = 2;
  V[2] = 3;

  W = 2;

  // Compared to some other C++ linear algebra libraries you cannot
  // write "exotic" expressions like: W=W+1+3*V
  //
  // The price to pay is to write something like:
  //
  transform([](const auto Wi, const auto Vi) { return Wi + 1 + 3 * Vi; }, W, V);

  // Beside "transform", some other specialized functions are
  // avalaible, see:
  //
  // - fill(), fill_indexed()
  //
  // - transform(), transform_indexed()
  //
  // - scan(), scan_indexed()
  //
  std::cout << W;
}
#+END_src

** Static size matrices

For the moment I have not introduced all the 
- I did not introduce =aligned= or =packed= template parameters (by
  consequence I did not introduce simd intrinsics). This can be a
  performance limitation for small vector/matrix objects. However,
  this has no effect for big vector/matrix as we use BLAS whenever
  this is possible.

* Examples

** Matrix types 

For the moment I only have define =dense= matrices (BLAS compatible with column major order):

#+BEGIN_SRC sh :wrap "src cpp :eval never" :results output :exports results
cat $(pwd)/examples/some_matrix_types.cpp
#+END_SRC

#+RESULTS:
#+begin_src cpp :eval never
#include "LinearAlgebra/dense/matrix.hpp"
#include "LinearAlgebra/dense/vector.hpp"

#include <iostream>

using namespace LinearAlgebra;

int
main()
{
  Matrix<double> M_1(4, 5);

  Symmetric_Matrix<int> M_2(4, 4);

  Tiny_Lower_Triangular_Strict_Matrix<float, 4, 7> M_3;

  std::cout << M_1 << std::endl;
  std::cout << M_2 << std::endl;
  std::cout << M_3 << std::endl;
}
#+end_src

prints

#+BEGIN_SRC sh :wrap "example :eval never" :results output :exports results
./build/examples/some_matrix_types
#+END_SRC

#+RESULTS:
#+begin_example :eval never

               0               0               0               0               0
               0               0               0               0               0
               0               0               0               0               0
               0               0               0               0               0

               0               X               X               X
               0               0               X               X
               0               0               0               X
               0               0               0               0

               X               X               X               X               X               X               X
               0               X               X               X               X               X               X
               0               0               X               X               X               X               X
               0               0               0               X               X               X               X
#+end_example

The generic definition for these matrix types is:
#+begin_src cpp :eval never
template <typename T,                     // is the component type
          Matrix_Special_Structure_Enum   //
              SPECIAL_STRUCTURE,          // is in {None, Symmetric, Hermitian, Triangular,
                                          //        Unit_Triangular, Triangular_Strict}
          Matrix_Storage_Mask_Enum MASK,  // is in {None, Upper, Upper_Strict, Lower, Lower_Strict }
          typename N_TYPE,                // std::size_t or a std::integral_constant<std::size_t,N>
          typename M_TYPE,                // std::size_t or a std::integral_constant<std::size_t,M>
          typename LEADING_DIMENSION      // std::size_t or a std::integral_constant<std::size_t,LD>
          >                               //
class Default_Matrix;                     // or {Default_Matrix_View, Default_Matrix_Const_View}
#+end_src

There are some alias covering the usual cases. Those with the =Tiny=
prefix denote *static size* (no memory allocation).

#+begin_src cpp :eval never
Matrix<T> M(I_size, J_size);
Tiny_Matrix<T, I_SIZE, J_SIZE> M;

Lower_Triangular_Strict_Matrix<T> M(I_size_, J_size);
Tiny_Lower_Triangular_Strict_Matrix<T, I_SIZE, J_SIZE> M;

Upper_Triangular_Strict_Matrix<T> M(I_size_, J_size);
Tiny_Upper_Triangular_Strict_Matrix<T, I_SIZE, J_SIZE> M;

Lower_Unit_Triangular_Matrix<T> M(I_size_, J_size);
Tiny_Lower_Unit_Triangular_Matrix<T, I_SIZE, J_SIZE> M;

Upper_Unit_Triangular_Matrix<T> MI_size_, J_size);
Tiny_Upper_Unit_Triangular_Matrix<T, I_SIZE, J_SIZE> M;

Symmetric_Matrix<T> M(I_size_, J_size);  // I_size = J_size
Tiny_Symmetric_Matrix<T, I_SIZE, J_SIZE> M;

Hermitian_Matrix<T> M;  // I_size = J_size
Tiny_Hermitian_Matrix<T, I_SIZE, J_SIZE> M;
#+end_src

Please note that by default Symmetric/Hermitian matrices are stored in their *Lower* part.

For each case you can also use *views*, there are two types of view:
mutable one and constant one. For instance:

#+begin_src cpp :eval never
Matrix<double> M(10, 5);

auto view = view_as_lower_triangular_strict(M.as_const());
#+end_src

will return a constant view (a lightweight matrix where only pointers
are stored and not owned) of type.

* FAQ

** Resizable vector/matrix ?

In general vectors or matrices *cannot be resized*. 

Reason: this avoid introducing an asymmetry in the code between
dynamic & static size objects. This asymmetry would have come with
some extra complications both for the developer and the user who want
to implement some generic routines.
