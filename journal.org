#+SETUPFILE: Setup/setupFile.org
#+TITLE: Journal
* 2020
** 2020-03 March
*** 2020-03-19 Thursday

****  =transform=, =map= design error                                    :Design:

     Refactoring of =transform=, =map=...

     #+BEGIN_SRC cpp :eval never
template <typename IMPL, typename LAMBDA>
void
transform_indexed(Dense_Matrix_Crtp<IMPL>& matrix, const LAMBDA& lambda)
{
  ...
}
     #+END_SRC

     to 

     #+BEGIN_SRC cpp :eval never
template <typename LAMBDA, typename... IMPL>
void
transform_indexed(const LAMBDA& lambda, Dense_Matrix_Crtp<IMPL>& matrix...)
{
  ...
}
     #+END_SRC

     Reason: having several =IMPL...= allow us to chose the one that have static size

**** Usage example

     To compute
     $$
     v_0=v_0 + v_1
     $$

     with $v_1$ *static* size and $v_0$ *dynamic* size.

     *Before:*

     #+BEGIN_SRC cpp :eval never
transform_indexed(v_0,[&v_1](const auto& v_0_i,const size_t i){ return v_0_i + v_1[i]; });
     #+END_SRC

     Problem -> the loop is performed using $v_0$'s dynamic size

     *After:*

     #+BEGIN_SRC cpp :eval never
transform(v_0,v_1,[](const auto& v_0_i,const auto v_1_i){ return v_0_i + v_1_i; });
     #+END_SRC

     -> all the burden of testing/choosing the static size value is
     encapsulated into the =transform= procedure & static size is chosen.
*** 2020-03-21 Saturday

**** Bound convention                                     :Design:Convention:

     Back link: [[file:src/LinearAlgebra/dense/vector_view.hpp][vector_view.hpp example]]

     #+BEGIN_EXAMPLE
     CAVEAT: for views our convention is *always* to use [begin,end[ and NOT (begin,size)
             by example view(2,4) mean {v_2,v_3}, begin=2, end=4 (and NOT {v_2,v_3,v_4,v_5}, begin=2, size=4)) 
     #+END_EXAMPLE
*** 2020-03-22 Sunday

**** Symmetric/Hermiatian default: lower                                :Doc:

     #+BEGIN_QUOTE
     template <typename T>
     using Symmetric_Matrix = Default_Matrix<T, Matrix_Special_Structure_Enum::Symmetric,
     Matrix_Storage_Mask_Enum::Lower, size_t, size_t, size_t>;

     #+END_QUOTE
*** 2020-03-28 Saturday

**** assign return a DYNAMIC value, not a TYPE                       :CAVEAT:

     Back link: [[file:src/LinearAlgebra/expr/V_assign_alpha_V.hpp][file:src/LinearAlgebra/expr/V_assign_alpha_V.hpp]]

     I tried several time to return a type (std::integral_constant...)

     But this is NOT a good idea

     Typical example:

     #+BEGIN_SRC cpp :eval never
// V0 = Î± V1
template <typename IMPL_DEST, typename IMPL_ARG_1>
static inline auto
assign(Vector_Crtp<IMPL_DEST>& dest,                              //// dest
       const Common_Element_Type_t<IMPL_DEST, IMPL_ARG_1> alpha,  //// alpha
       const Vector_Crtp<IMPL_ARG_1>& arg_1                       // arg_1
       )
{
  if (is_same(dest, arg_1))
    {
      return assign(Expr_Selector<>(), dest.impl(), alpha, _vector_0_);
    }
  else
    {
      return assign(Expr_Selector<>(), dest.impl(), alpha, arg_1.impl());
    }
}
     #+END_SRC

     Conclusion one must return a =Expr_Selector_Enum=
*** 2020-03-30 Monday

**** vector_comparison_operators.hpp                             :Bug:Caveat:

     Back link: [[file:src/LinearAlgebra/dense/vector_comparison_operators.hpp][file:~/GitHub/LinearAlgebra/src/LinearAlgebra/dense/vector_comparison_operators.hpp]]

     One bug to clarify!

     #+BEGIN_EXAMPLE
CAVEAT: do not define >= as !< (for array).                               
                                                                     
Reason: if you do so you will have:                                          
   (1)  (1,1) <  (1,1)  FALSE                                             
        but, if >= is !<                                                  
   (2)  (1,0) >= (1,1) TRUE <- which is NOT what we expect                
                                                                          
   (1)  (a0 < b0) and (a1 < b1)                                           
but !(1) is                                                               
   (2)  (a0 >= b0) or (a1 >= b1) (but we want (a0 >= b0) _AND_ (a1 >= b1))
                                                                          
     #+END_EXAMPLE
