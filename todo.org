#+TITLE: Reminder & TODO list

* TODO list

* Some Reminders

  - Note taken on [2020-04-15 Wed 16:33] \\
    Begin,End versus Begin,Size convention:
    
    #+BEGIN_EXAMPLE
         CAVEAT: for views our convention is *always* to use [begin,end[ and NOT (begin,size)
                 by example view(2,4) mean {v_2,v_3}, begin=2, end=4 (and NOT {v_2,v_3,v_4,v_5}, begin=2, size=4)) 
    #+END_EXAMPLE

  - Note taken on [2020-04-15 Wed 16:31] \\
    Comparison operators, one bug to clarify:
    
    #+BEGIN_EXAMPLE
    
    CAVEAT: DO NOT DEFINE >= AS !< (FOR ARRAY).                               
                                                                         
    Reason: if you do so you will have:                                          
       (1)  (1,1) <  (1,1)  FALSE                                             
            but, if >= is !<                                                  
       (2)  (1,0) >= (1,1) TRUE <- which is NOT what we expect                
                                                                              
       (1)  (a0 < b0) and (a1 < b1)                                           
    but !(1) is                                                               
       (2)  (a0 >= b0) or (a1 >= b1) (but we want (a0 >= b0) _AND_ (a1 >= b1))
                                                                              
    #+END_EXAMPLE

  - Note taken on [2020-04-15 Wed 16:29] \\
    ADL example
    
    #+BEGIN_SRC cpp :eval never
    namespace LinearAlgebra
    {
      namespace Detail
      {
        struct Detail_ADL
        {
        };
    
        template <typename IMPL_0, typename IMPL_1>
        bool
        impl_comparison(const Detail_ADL detail_ADL, const Vector_Crtp<IMPL_0>& vector_0,
    		    const Vector_Crtp<IMPL_1>& vector_1)
        {
          return impl_comparison(detail_ADL, vector_0.impl(), vector_1.impl());
        }
      }
    
      template <typename IMPL_0, typename IMPL_1>
      bool
      operator==(const Vector_Crtp<IMPL_0>& vector_0, const Vector_Crtp<IMPL_1>& vector_1)
      {
        return impl_comparison(Detail::Detail_ADL(), vector_0, vector_1);
      }
    
      namespace Detail
      {
        template <typename IMPL_0, typename IMPL_1>
        bool
        impl_comparison(const Detail_ADL detail_ADL, const Dense_Vector_Crtp<IMPL_0>& vector_0,
    		    const Dense_Vector_Crtp<IMPL_1>& vector_1)
        {
          return true;
        }
      }
    }
    #+END_SRC
    
    Archived, for the moment we do not systematically use this kind of stuff

  - Note taken on [2020-04-15 Wed 16:29] \\
    To prevent object slicing it is important to define this kind of stuff
    
    #+BEGIN_SRC cpp :eval never
    template <typename IMPL>
    class Dense_Vector_Crtp
    {
    protected: // <- CAVEAT
      Dense_Vector_Crtp()                         = default;
      Dense_Vector_Crtp(const Dense_Vector_Crtp&) = default;
      Dense_Vector_Crtp(Dense_Vector_Crtp&) = default;
      Dense_Vector_Crtp& operator=(const Dense_Vector_Crtp&) = default;
      Dense_Vector_Crtp& operator=(Dense_Vector_Crtp&) = default;
    };
    #+END_SRC

